	Session.vim	/^imap <silent>  =strftime("%Y\/%m\/%d")$/;"	m
	Session.vim	/^imap <silent>  =strftime("%H:%M:%S")$/;"	m
c	Session.vim	/^nmap c :cs find c =expand("<cword>")$/;"	m
d	Session.vim	/^nmap d :cs find d =expand("<cword>")$/;"	m
e	Session.vim	/^nmap e :cs find e =expand("<cword>")$/;"	m
f	Session.vim	/^nmap f :cs find f =expand("<cfile>")$/;"	m
g	Session.vim	/^nmap g :cs find g =expand("<cword>")$/;"	m
i	Session.vim	/^nmap i :cs find i ^=expand("<cfile>")$/;"	m
s	Session.vim	/^nmap s :cs find s =expand("<cword>")$/;"	m
t	Session.vim	/^nmap t :cs find t =expand("<cword>")$/;"	m
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
#	Session.vim	/^nnoremap # #zz$/;"	m
*	Session.vim	/^nnoremap * *zz$/;"	m
,H	Session.vim	/^nmap ,H :sf %:t:r.h$/;"	m
,S	Session.vim	/^nmap ,S :sf %:t:r.c$/;"	m
,V	Session.vim	/^map ,V :spl ~\/.vimrc$/;"	m
,W	Session.vim	/^map <silent> ,W :source ~\/.vimrc$/;"	m
,c	Session.vim	/^imap <silent> ,c <Plug>Traditionalji$/;"	m
,c	Session.vim	/^nmap <silent> ,c <Plug>Traditionalj$/;"	m
,c	Session.vim	/^vmap <silent> ,c <Plug>VisualTraditionalj$/;"	m
,fq	Session.vim	/^nmap ,fq :call FlipQuote()$/;"	m
,h	Session.vim	/^nmap ,h :find %:t:r.h$/;"	m
,h	Session.vim	/^onoremap <silent> ,h h_$/;"	m
,h	Session.vim	/^vnoremap <silent> ,h h_$/;"	m
,j	Session.vim	/^noremap <silent> ,j j_$/;"	m
,k	Session.vim	/^noremap <silent> ,k k_$/;"	m
,l	Session.vim	/^map ,l :set list!$/;"	m
,s	Session.vim	/^nmap ,s :find %:t:r.c$/;"	m
,sb	Session.vim	/^map ,sb msvi(:sort u$/;"	m
,sp	Session.vim	/^map ,sp ms(V)k:sort u$/;"	m
,tl	Session.vim	/^nmap ,tl :TlistToggle$/;"	m
,x	Session.vim	/^imap <silent> ,x <Plug>Traditional$/;"	m
,x	Session.vim	/^nmap <silent> ,x <Plug>Traditional$/;"	m
,x	Session.vim	/^vmap <silent> ,x <Plug>VisualTraditional$/;"	m
0	Session.vim	/^normal! 0$/;"	m
020l	Session.vim	/^normal! 020l$/;"	m
025l	Session.vim	/^normal! 025l$/;"	m
02l	Session.vim	/^normal! 02l$/;"	m
030l	Session.vim	/^normal! 030l$/;"	m
032l	Session.vim	/^normal! 032l$/;"	m
03l	Session.vim	/^normal! 03l$/;"	m
05l	Session.vim	/^normal! 05l$/;"	m
08l	Session.vim	/^normal! 08l$/;"	m
<C-Down>	Session.vim	/^noremap <silent> <C-Down> j_$/;"	m
<C-Left>	Session.vim	/^noremap <silent> <C-Left> h_$/;"	m
<C-Right>	Session.vim	/^noremap <silent> <C-Right> l_$/;"	m
<C-Up>	Session.vim	/^noremap <silent> <C-Up> k_$/;"	m
<F3>	Session.vim	/^noremap <silent> <F3> :previous$/;"	m
<F4>	Session.vim	/^noremap <silent> <F4> :next$/;"	m
<F5>	Session.vim	/^nmap <F5> :call FlipQuote()$/;"	m
<F6>	Session.vim	/^noremap <silent> <F6> :call g:align_assignments()$/;"	m
<F7>	Session.vim	/^noremap <silent> <F7> :cprevious$/;"	m
<F8>	Session.vim	/^noremap <silent> <F8> :cnext$/;"	m
<Nul><Nul>c	Session.vim	/^nmap <Nul><Nul>c :vert scs find c =expand("<cword>")$/;"	m
<Nul><Nul>d	Session.vim	/^nmap <Nul><Nul>d :vert scs find d =expand("<cword>")$/;"	m
<Nul><Nul>e	Session.vim	/^nmap <Nul><Nul>e :vert scs find e =expand("<cword>")$/;"	m
<Nul><Nul>f	Session.vim	/^nmap <Nul><Nul>f :vert scs find f =expand("<cfile>")$/;"	m
<Nul><Nul>g	Session.vim	/^nmap <Nul><Nul>g :vert scs find g =expand("<cword>")$/;"	m
<Nul><Nul>i	Session.vim	/^nmap <Nul><Nul>i :vert scs find i ^=expand("<cfile>")$/;"	m
<Nul><Nul>s	Session.vim	/^nmap <Nul><Nul>s :vert scs find s =expand("<cword>")$/;"	m
<Nul><Nul>t	Session.vim	/^nmap <Nul><Nul>t :vert scs find t =expand("<cword>")$/;"	m
<Nul>c	Session.vim	/^nmap <Nul>c :scs find c =expand("<cword>")$/;"	m
<Nul>d	Session.vim	/^nmap <Nul>d :scs find d =expand("<cword>")$/;"	m
<Nul>e	Session.vim	/^nmap <Nul>e :scs find e =expand("<cword>")$/;"	m
<Nul>f	Session.vim	/^nmap <Nul>f :scs find f =expand("<cfile>")$/;"	m
<Nul>g	Session.vim	/^nmap <Nul>g :scs find g =expand("<cword>")$/;"	m
<Nul>i	Session.vim	/^nmap <Nul>i :scs find i ^=expand("<cfile>")$/;"	m
<Nul>s	Session.vim	/^nmap <Nul>s :scs find s =expand("<cword>")$/;"	m
<Nul>t	Session.vim	/^nmap <Nul>t :scs find t =expand("<cword>")$/;"	m
<Plug>Comment	Session.vim	/^noremap <Plug>Comment :call EnhancedCommentify('', 'comment')$/;"	m
<Plug>DeComment	Session.vim	/^noremap <Plug>DeComment :call EnhancedCommentify('', 'decomment')$/;"	m
<Plug>FirstLine	Session.vim	/^noremap <Plug>FirstLine :call EnhancedCommentify('', 'first')$/;"	m
<Plug>NetrwBrowseX	Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)$/;"	m
<Plug>Traditional	Session.vim	/^noremap <Plug>Traditional :call EnhancedCommentify('', 'guess')$/;"	m
<Plug>VisualComment	Session.vim	/^noremap <Plug>VisualComment :call EnhancedCommentify('', 'comment',   line("'<"), line("'>"))$/;"	m
<Plug>VisualDeComment	Session.vim	/^noremap <Plug>VisualDeComment :call EnhancedCommentify('', 'decomment',   line("'<"), line("'>"))$/;"	m
<Plug>VisualFirstLine	Session.vim	/^noremap <Plug>VisualFirstLine :call EnhancedCommentify('', 'first',   line("'<"), line("'>"))$/;"	m
<Plug>VisualTraditional	Session.vim	/^noremap <Plug>VisualTraditional :call EnhancedCommentify('', 'guess',   line("'<"), line("'>"))$/;"	m
AVLIBS	Makefile	/^AVLIBS=libavcodec libavformat libavutil libswscale$/;"	m
BINOBJS	Makefile	/^BINOBJS=$(addsuffix .o,$(BINS))$/;"	m
BINS	Makefile	/^BINS=dynatron$/;"	m
CFLAGS	common.mk	/^CFLAGS=-Wall -Werror -g2 -D_LARGEFILE64_SOURCE$/;"	m
COLOR_RESET	dy_log.c	35;"	d	file:
CTESTS	t/Makefile	/^CTESTS=$(wildcard *.xt)$/;"	m
DEBUG	dynatron.h	/^  DEBUG$/;"	e	enum:__anon1
DEPS	Makefile	/^DEPS=$(OBJS:.o=.d) $/;"	m
DEPS	t/Makefile	/^DEPS=$(OBJ:.o=.d) $/;"	m
DYNATRON	t/listen.t	/^use constant DYNATRON => "$FindBin::Bin\/..\/dynatron";$/;"	c
Dynatron::Client	perl/lib/Dynatron/Client.pm	/^package Dynatron::Client;$/;"	p
Dynatron::Client::_read	perl/lib/Dynatron/Client.pm	/^sub _read {$/;"	s
Dynatron::Client::receive	perl/lib/Dynatron/Client.pm	/^sub receive {$/;"	s
Dynatron::Client::send	perl/lib/Dynatron/Client.pm	/^sub send {$/;"	s
ERROR	dynatron.h	/^  ERROR,$/;"	e	enum:__anon1
FATAL	dynatron.h	/^  FATAL,$/;"	e	enum:__anon1
HDR	t/util.c	21;"	d	file:
INFO	dynatron.h	/^  INFO,$/;"	e	enum:__anon1
INST_BINS	Makefile	/^INST_BINS=$(PREFIX)\/bin$/;"	m
LDFLAGS	common.mk	/^LDFLAGS=-lc -lm$/;"	m
LIB	Makefile	/^LIB=libdynatron.a$/;"	m
LIBOBJS	Makefile	/^LIBOBJS=utils.o dy_message.o dy_despatch.o dy_main.o dy_log.o \\$/;"	m
LIBS	t/Makefile	/^LIBS=..\/..\/jsondata\/libjsondata.a ..\/libdynatron.a$/;"	m
LOGGER	dy_log.c	85;"	d	file:
MAX_PREFIX	t/tap.c	9;"	d	file:
MEM	t/util.c	22;"	d	file:
MISCOBJ	t/Makefile	/^MISCOBJ=tap.o util.o jd_test.o$/;"	m
MYLIBS	Makefile	/^MYLIBS=..\/jsondata\/libjsondata.a$/;"	m
N	Session.vim	/^nnoremap N Nzz$/;"	m
NATIVE	dynatron.h	/^  NATIVE,$/;"	e	enum:__anon3
OBJ	t/Makefile	/^OBJ=$(CTESTOBJ) $(MISCOBJ)$/;"	m
OBJS	Makefile	/^OBJS=$(BINOBJS) $(LIBOBJS)$/;"	m
PERLTESTS	t/Makefile	/^PERLTESTS=$(wildcard *.t)$/;"	m
PREFIX	Makefile	/^PREFIX ?= \/usr\/local$/;"	m
PROG	dynatron.c	13;"	d	file:
SIG	t/util.c	11;"	d	file:
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
TD_SERIAL	dynatron.h	/^  TD_SERIAL$/;"	e	enum:__anon2
TESTBIN	t/Makefile	/^TESTBIN=$(TESTOBJ:.o=.T) $(PERLTESTS:.t=.T)$/;"	m
TESTOBJ	t/Makefile	/^TESTOBJ=$(CTESTS:.xt=.o)$/;"	m
TF	t/tap.h	19;"	d
TS_FORMAT	dy_log.c	12;"	d	file:
VAR	dynatron.h	/^  VAR$/;"	e	enum:__anon3
V_DATE	version.h	7;"	d
V_GIT_HASH	version.h	6;"	d
V_INFO	version.h	9;"	d
V_VERSION	version.h	8;"	d
WARNING	dynatron.h	/^  WARNING,$/;"	e	enum:__anon1
__DYNATRON_H	dynatron.h	4;"	d
__JD_TEST_H	t/jd_test.h	4;"	d
__TAP_H	t/tap.h	4;"	d
__UTILS_H	utils.h	4;"	d
__UTIL_H	t/util.h	4;"	d
__VERSION_H	version.h	4;"	d
__anon4::__anon5::__anon6::buf	dynatron.h	/^      char *buf;$/;"	m	struct:__anon4::__anon5::__anon6	access:public
__anon4::__anon5::__anon6::fd	dynatron.h	/^      int fd;$/;"	m	struct:__anon4::__anon5::__anon6	access:public
__anon4::__anon5::__anon6::size	dynatron.h	/^      size_t size, used;$/;"	m	struct:__anon4::__anon5::__anon6	access:public
__anon4::__anon5::__anon6::used	dynatron.h	/^      size_t size, used;$/;"	m	struct:__anon4::__anon5::__anon6	access:public
__anon4::__anon5::n	dynatron.h	/^    } n;$/;"	m	union:__anon4::__anon5	typeref:struct:__anon4::__anon5::__anon6	access:public
__anon4::__anon5::v	dynatron.h	/^    jd_var v;$/;"	m	union:__anon4::__anon5	access:public
__anon4::h	dynatron.h	/^  } h;$/;"	m	struct:__anon4	typeref:union:__anon4::__anon5	access:public
__anon4::pos	dynatron.h	/^  unsigned pos;$/;"	m	struct:__anon4	access:public
__anon4::type	dynatron.h	/^  dy_io_type type;$/;"	m	struct:__anon4	access:public
__anon7::__anon8::fd	dynatron.h	/^    int fd;$/;"	m	union:__anon7::__anon8	access:public
__anon7::__anon8::v	dynatron.h	/^    jd_var v;$/;"	m	union:__anon7::__anon8	access:public
__anon7::h	dynatron.h	/^  } h;$/;"	m	struct:__anon7	typeref:union:__anon7::__anon8	access:public
__anon7::type	dynatron.h	/^  dy_io_type type;$/;"	m	struct:__anon7	access:public
__anon9::cond	dynatron.h	/^  pthread_cond_t cond;$/;"	m	struct:__anon9	access:public
__anon9::mutex	dynatron.h	/^  pthread_mutex_t mutex;$/;"	m	struct:__anon9	access:public
__anon9::queue	dynatron.h	/^  jd_var queue;$/;"	m	struct:__anon9	access:public
_is	t/jd_test.c	/^static int _is(jd_var *got, jd_var *want, const char *msg, va_list ap) {$/;"	f	file:	signature:(jd_var *got, jd_var *want, const char *msg, va_list ap)
_read	perl/lib/Dynatron/Client.pm	/^sub _read {$/;"	s
active	dy_thread.c	/^static struct thread_context *active = NULL;$/;"	v	typeref:struct:thread_context	file:
active_mutex	dy_thread.c	/^static pthread_mutex_t active_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
add_thread	dy_thread.c	/^static void add_thread(struct thread_context *ctx) {$/;"	f	file:	signature:(struct thread_context *ctx)
alloc	utils.c	/^void *alloc(size_t sz) {$/;"	f	signature:(size_t sz)
alloc	utils.h	/^void *alloc(size_t sz);$/;"	p	signature:(size_t sz)
arg	dy_thread.c	/^  jd_var arg;$/;"	m	struct:thread_context	file:	access:public
bl	Session.vim	/^vmap bl :!svn blame =expand("%:p") $/;"	m
buf	dynatron.h	/^      char *buf;$/;"	m	struct:__anon4::__anon5::__anon6	access:public
check_leaks	t/util.c	/^static void check_leaks(void) {$/;"	f	file:	signature:(void)
clone_h	dy_core.c	/^static int clone_h(jd_var *self, jd_var *ctx, jd_var *arg) {$/;"	f	file:	signature:(jd_var *self, jd_var *ctx, jd_var *arg)
cond	dynatron.h	/^  pthread_cond_t cond;$/;"	m	struct:__anon9	access:public
create_thread	dy_thread.c	/^static dy_thread create_thread(dy_worker worker, jd_var *arg) {$/;"	f	file:	signature:(dy_worker worker, jd_var *arg)
ctx_free	dy_object.c	/^static void ctx_free(struct object_context *ctx) {$/;"	f	file:	signature:(struct object_context *ctx)
ctx_free_wrap	dy_object.c	/^static void ctx_free_wrap(void *ctx) {$/;"	f	file:	signature:(void *ctx)
ctx_new	dy_object.c	/^static struct object_context *ctx_new(void) {$/;"	f	file:	signature:(void)
define	tools/version.pl	/^sub define($$) {$/;"	s
describe	dy_core.c	/^static void describe(jd_var *self) {$/;"	f	file:	signature:(jd_var *self)
despatch	dy_despatch.c	/^static jd_var despatch = JD_INIT;$/;"	v	file:
despatch_message	dy_core.c	/^static void despatch_message(jd_var *self, jd_var *msg) {$/;"	f	file:	signature:(jd_var *self, jd_var *msg)
diag	t/tap.c	/^void diag(const char *fmt, ...) {$/;"	f	signature:(const char *fmt, ...)
diag	t/tap.h	/^void diag(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
die	t/tap.c	/^void die(const char *fmt, ...) {$/;"	f	signature:(const char *fmt, ...)
die	t/tap.h	/^void die(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
die	utils.c	/^void die(const char *msg, ...) {$/;"	f	signature:(const char *msg, ...)
die	utils.h	/^void die(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
done_testing	t/tap.c	/^void done_testing(void) {$/;"	f	signature:(void)
done_testing	t/tap.h	/^void done_testing(void);$/;"	p	signature:(void)
dy_core_destroy	dy_core.c	/^void dy_core_destroy(void) {$/;"	f	signature:(void)
dy_core_destroy	dynatron.h	/^void dy_core_destroy(void);$/;"	p	signature:(void)
dy_core_init	dy_core.c	/^void dy_core_init(void) {$/;"	f	signature:(void)
dy_core_init	dynatron.h	/^void dy_core_init(void);$/;"	p	signature:(void)
dy_debug	dynatron.h	/^void dy_debug(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
dy_despatch_destroy	dy_despatch.c	/^void dy_despatch_destroy(void) {$/;"	f	signature:(void)
dy_despatch_destroy	dynatron.h	/^void dy_despatch_destroy(void);$/;"	p	signature:(void)
dy_despatch_enqueue	dy_despatch.c	/^void dy_despatch_enqueue(jd_var *msg) {$/;"	f	signature:(jd_var *msg)
dy_despatch_enqueue	dynatron.h	/^void dy_despatch_enqueue(jd_var *msg);$/;"	p	signature:(jd_var *msg)
dy_despatch_init	dy_despatch.c	/^void dy_despatch_init(void) {$/;"	f	signature:(void)
dy_despatch_init	dynatron.h	/^void dy_despatch_init(void);$/;"	p	signature:(void)
dy_despatch_message	dy_despatch.c	/^void dy_despatch_message(jd_var *msg) {$/;"	f	signature:(jd_var *msg)
dy_despatch_message	dynatron.h	/^void dy_despatch_message(jd_var *msg);$/;"	p	signature:(jd_var *msg)
dy_despatch_register	dy_despatch.c	/^jd_var *dy_despatch_register(const char *verb, jd_closure_func f) {$/;"	f	signature:(const char *verb, jd_closure_func f)
dy_despatch_register	dynatron.h	/^jd_var *dy_despatch_register(const char *verb, jd_closure_func f);$/;"	p	signature:(const char *verb, jd_closure_func f)
dy_despatch_thread	dy_despatch.c	/^void dy_despatch_thread(jd_var *arg) {$/;"	f	signature:(jd_var *arg)
dy_despatch_thread	dynatron.h	/^void dy_despatch_thread(jd_var *arg);$/;"	p	signature:(jd_var *arg)
dy_destroy	dy_main.c	/^void dy_destroy(void) {$/;"	f	signature:(void)
dy_destroy	dynatron.h	/^void dy_destroy(void);$/;"	p	signature:(void)
dy_dummy_destroy	dy_dummy.c	/^void dy_dummy_destroy(void) {$/;"	f	signature:(void)
dy_dummy_destroy	dynatron.h	/^void dy_dummy_destroy(void);$/;"	p	signature:(void)
dy_dummy_init	dy_dummy.c	/^void dy_dummy_init(void) {$/;"	f	signature:(void)
dy_dummy_init	dynatron.h	/^void dy_dummy_init(void);$/;"	p	signature:(void)
dy_error	dynatron.h	/^void dy_error(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
dy_fatal	dynatron.h	/^void dy_fatal(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
dy_info	dynatron.h	/^void dy_info(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
dy_init	dy_main.c	/^void dy_init(void) {$/;"	f	signature:(void)
dy_init	dynatron.h	/^void dy_init(void);$/;"	p	signature:(void)
dy_io_consume	dy_io.c	/^void dy_io_consume(dy_io_reader *rd, size_t len) {$/;"	f	signature:(dy_io_reader *rd, size_t len)
dy_io_consume	dynatron.h	/^void dy_io_consume(dy_io_reader *rd, size_t len);$/;"	p	signature:(dy_io_reader *rd, size_t len)
dy_io_free_reader	dy_io.c	/^void dy_io_free_reader(dy_io_reader *rd) {$/;"	f	signature:(dy_io_reader *rd)
dy_io_free_reader	dynatron.h	/^void dy_io_free_reader(dy_io_reader *rd);$/;"	p	signature:(dy_io_reader *rd)
dy_io_free_writer	dy_io.c	/^void dy_io_free_writer(dy_io_writer *wr) {$/;"	f	signature:(dy_io_writer *wr)
dy_io_free_writer	dynatron.h	/^void dy_io_free_writer(dy_io_writer *wr);$/;"	p	signature:(dy_io_writer *wr)
dy_io_getvar	dy_io.c	/^jd_var *dy_io_getvar(dy_io_writer *wr) {$/;"	f	signature:(dy_io_writer *wr)
dy_io_getvar	dynatron.h	/^jd_var *dy_io_getvar(dy_io_writer *wr);$/;"	p	signature:(dy_io_writer *wr)
dy_io_new_reader	dy_io.c	/^dy_io_reader *dy_io_new_reader(int fd, size_t size) {$/;"	f	signature:(int fd, size_t size)
dy_io_new_reader	dynatron.h	/^dy_io_reader *dy_io_new_reader(int fd, size_t size);$/;"	p	signature:(int fd, size_t size)
dy_io_new_var_reader	dy_io.c	/^dy_io_reader *dy_io_new_var_reader(jd_var *v) {$/;"	f	signature:(jd_var *v)
dy_io_new_var_reader	dynatron.h	/^dy_io_reader *dy_io_new_var_reader(jd_var *v);$/;"	p	signature:(jd_var *v)
dy_io_new_var_writer	dy_io.c	/^dy_io_writer *dy_io_new_var_writer(jd_var *v) {$/;"	f	signature:(jd_var *v)
dy_io_new_var_writer	dynatron.h	/^dy_io_writer *dy_io_new_var_writer(jd_var *v);$/;"	p	signature:(jd_var *v)
dy_io_new_writer	dy_io.c	/^dy_io_writer *dy_io_new_writer(int fd) {$/;"	f	signature:(int fd)
dy_io_new_writer	dynatron.h	/^dy_io_writer *dy_io_new_writer(int fd);$/;"	p	signature:(int fd)
dy_io_read	dy_io.c	/^ssize_t dy_io_read(dy_io_reader *rd, char **bp) {$/;"	f	signature:(dy_io_reader *rd, char **bp)
dy_io_read	dynatron.h	/^ssize_t dy_io_read(dy_io_reader *rd, char **bp);$/;"	p	signature:(dy_io_reader *rd, char **bp)
dy_io_reader	dynatron.h	/^} dy_io_reader;$/;"	t	typeref:struct:__anon4
dy_io_type	dynatron.h	/^} dy_io_type;$/;"	t	typeref:enum:__anon3
dy_io_write	dy_io.c	/^ssize_t dy_io_write(dy_io_writer *wr, const void *buf, size_t len) {$/;"	f	signature:(dy_io_writer *wr, const void *buf, size_t len)
dy_io_write	dynatron.h	/^ssize_t dy_io_write(dy_io_writer *wr, const void *buf, size_t len);$/;"	p	signature:(dy_io_writer *wr, const void *buf, size_t len)
dy_io_writer	dynatron.h	/^} dy_io_writer;$/;"	t	typeref:struct:__anon7
dy_listener_destroy	dy_listener.c	/^void dy_listener_destroy(void) {$/;"	f	signature:(void)
dy_listener_destroy	dynatron.h	/^void dy_listener_destroy(void);$/;"	p	signature:(void)
dy_listener_init	dy_listener.c	/^void dy_listener_init(void) {$/;"	f	signature:(void)
dy_listener_init	dynatron.h	/^void dy_listener_init(void);$/;"	p	signature:(void)
dy_listener_send	dy_listener.c	/^void dy_listener_send(jd_var *msg) {$/;"	f	signature:(jd_var *msg)
dy_listener_send	dynatron.h	/^void dy_listener_send(jd_var *msg);$/;"	p	signature:(jd_var *msg)
dy_listener_send_error	dy_listener.c	/^void dy_listener_send_error(const char *msg, ...) {$/;"	f	signature:(const char *msg, ...)
dy_listener_send_error	dynatron.h	/^void dy_listener_send_error(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
dy_log	dy_log.c	/^static void dy_log(unsigned level, const char *msg, va_list ap) {$/;"	f	file:	signature:(unsigned level, const char *msg, va_list ap)
dy_log_colour	dy_log.c	/^unsigned dy_log_colour = 1;$/;"	v
dy_log_level	dy_log.c	/^unsigned dy_log_level  = DEBUG;$/;"	v
dy_message_read	dy_message.c	/^jd_var *dy_message_read(jd_var *out, dy_io_reader *rd) {$/;"	f	signature:(jd_var *out, dy_io_reader *rd)
dy_message_read	dynatron.h	/^jd_var *dy_message_read(jd_var *out, dy_io_reader *rd);$/;"	p	signature:(jd_var *out, dy_io_reader *rd)
dy_message_write	dy_message.c	/^void dy_message_write(jd_var *v, dy_io_writer *wr) {$/;"	f	signature:(jd_var *v, dy_io_writer *wr)
dy_message_write	dynatron.h	/^void dy_message_write(jd_var *v, dy_io_writer *wr);$/;"	p	signature:(jd_var *v, dy_io_writer *wr)
dy_object_destroy	dy_object.c	/^void dy_object_destroy(void) {$/;"	f	signature:(void)
dy_object_destroy	dynatron.h	/^void dy_object_destroy(void);$/;"	p	signature:(void)
dy_object_get_message	dy_object.c	/^void dy_object_get_message(jd_var *o, jd_var *msg) {$/;"	f	signature:(jd_var *o, jd_var *msg)
dy_object_get_message	dynatron.h	/^void dy_object_get_message(jd_var *o, jd_var *msg);$/;"	p	signature:(jd_var *o, jd_var *msg)
dy_object_init	dy_object.c	/^void dy_object_init(void) {$/;"	f	signature:(void)
dy_object_init	dynatron.h	/^void dy_object_init(void);$/;"	p	signature:(void)
dy_object_invoke	dy_object.c	/^int dy_object_invoke(jd_var *o, const char *method, jd_var *arg) {$/;"	f	signature:(jd_var *o, const char *method, jd_var *arg)
dy_object_invoke	dynatron.h	/^int dy_object_invoke(jd_var *o, const char *method, jd_var *arg);$/;"	p	signature:(jd_var *o, const char *method, jd_var *arg)
dy_object_invokev	dy_object.c	/^int dy_object_invokev(jd_var *o, jd_var *method, jd_var *arg) {$/;"	f	signature:(jd_var *o, jd_var *method, jd_var *arg)
dy_object_invokev	dynatron.h	/^int dy_object_invokev(jd_var *o, jd_var *method, jd_var *arg);$/;"	p	signature:(jd_var *o, jd_var *method, jd_var *arg)
dy_object_name	dy_object.c	/^void dy_object_name(jd_var *o, jd_var *name) {$/;"	f	signature:(jd_var *o, jd_var *name)
dy_object_name	dynatron.h	/^void dy_object_name(jd_var *o, jd_var *name);$/;"	p	signature:(jd_var *o, jd_var *name)
dy_object_register	dy_object.c	/^void dy_object_register(const char *name, jd_var *o, const char *inherit) {$/;"	f	signature:(const char *name, jd_var *o, const char *inherit)
dy_object_register	dynatron.h	/^void dy_object_register(const char *name, jd_var *o, const char *inherit);$/;"	p	signature:(const char *name, jd_var *o, const char *inherit)
dy_object_set_method	dy_object.c	/^void dy_object_set_method(jd_var *obj, const char *method, jd_closure_func impl) {$/;"	f	signature:(jd_var *obj, const char *method, jd_closure_func impl)
dy_object_set_method	dynatron.h	/^void dy_object_set_method(jd_var *obj, const char *method, jd_closure_func impl);$/;"	p	signature:(jd_var *obj, const char *method, jd_closure_func impl)
dy_object_stash	dy_object.c	/^void dy_object_stash(jd_var *o, jd_var *stash) {$/;"	f	signature:(jd_var *o, jd_var *stash)
dy_object_stash	dynatron.h	/^void dy_object_stash(jd_var *o, jd_var *stash);$/;"	p	signature:(jd_var *o, jd_var *stash)
dy_object_unregister	dy_object.c	/^void dy_object_unregister(const char *name) {$/;"	f	signature:(const char *name)
dy_object_unregister	dynatron.h	/^void dy_object_unregister(const char *name);$/;"	p	signature:(const char *name)
dy_queue	dynatron.h	/^} dy_queue;$/;"	t	typeref:struct:__anon9
dy_queue_dequeue	dy_queue.c	/^void dy_queue_dequeue(dy_queue *q, jd_var *msg) {$/;"	f	signature:(dy_queue *q, jd_var *msg)
dy_queue_dequeue	dynatron.h	/^void dy_queue_dequeue(dy_queue *q, jd_var *msg);$/;"	p	signature:(dy_queue *q, jd_var *msg)
dy_queue_enqueue	dy_queue.c	/^void dy_queue_enqueue(dy_queue *q, jd_var *msg) {$/;"	f	signature:(dy_queue *q, jd_var *msg)
dy_queue_enqueue	dynatron.h	/^void dy_queue_enqueue(dy_queue *q, jd_var *msg);$/;"	p	signature:(dy_queue *q, jd_var *msg)
dy_queue_free	dy_queue.c	/^void dy_queue_free(dy_queue *q) {$/;"	f	signature:(dy_queue *q)
dy_queue_free	dynatron.h	/^void dy_queue_free(dy_queue *q);$/;"	p	signature:(dy_queue *q)
dy_queue_new	dy_queue.c	/^dy_queue *dy_queue_new(void) {$/;"	f	signature:(void)
dy_queue_new	dynatron.h	/^dy_queue *dy_queue_new(void);$/;"	p	signature:(void)
dy_set_handler	dy_main.c	/^jd_var *dy_set_handler(jd_var *desp, const char *verb, jd_closure_func f) {$/;"	f	signature:(jd_var *desp, const char *verb, jd_closure_func f)
dy_set_handler	dynatron.h	/^jd_var *dy_set_handler(jd_var *desp, const char *verb, jd_closure_func f);$/;"	p	signature:(jd_var *desp, const char *verb, jd_closure_func f)
dy_thread	dynatron.h	/^typedef struct thread_context *dy_thread;$/;"	t	typeref:struct:thread_context
dy_thread_count	dy_thread.c	/^size_t dy_thread_count(void) {$/;"	f	signature:(void)
dy_thread_count	dynatron.h	/^size_t dy_thread_count(void);$/;"	p	signature:(void)
dy_thread_create	dy_thread.c	/^dy_thread dy_thread_create(dy_worker worker, jd_var *arg) {$/;"	f	signature:(dy_worker worker, jd_var *arg)
dy_thread_create	dynatron.h	/^dy_thread dy_thread_create(dy_worker worker, jd_var *arg);$/;"	p	signature:(dy_worker worker, jd_var *arg)
dy_thread_id	dy_thread.c	/^unsigned long dy_thread_id(void) {$/;"	f	signature:(void)
dy_thread_join	dy_thread.c	/^void dy_thread_join(dy_thread td) {$/;"	f	signature:(dy_thread td)
dy_thread_join	dynatron.h	/^void dy_thread_join(dy_thread td);$/;"	p	signature:(dy_thread td)
dy_thread_join_all	dy_thread.c	/^void dy_thread_join_all(void) {$/;"	f	signature:(void)
dy_thread_join_all	dynatron.h	/^void dy_thread_join_all(void);$/;"	p	signature:(void)
dy_warning	dynatron.h	/^void dy_warning(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
dy_worker	dy_thread.c	/^typedef void (*dy_worker)(jd_var *arg);$/;"	t	file:
dy_worker	dynatron.h	/^typedef void (*dy_worker)(jd_var *arg);$/;"	t
fail	t/tap.c	/^int fail(const char *msg, ...) {$/;"	f	signature:(const char *msg, ...)
fail	t/tap.h	/^int fail(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
fd	dynatron.h	/^      int fd;$/;"	m	struct:__anon4::__anon5::__anon6	access:public
fd	dynatron.h	/^    int fd;$/;"	m	union:__anon7::__anon8	access:public
fillbuf	dy_io.c	/^static ssize_t fillbuf(dy_io_reader *rd) {$/;"	f	file:	signature:(dy_io_reader *rd)
find_obj	dy_object.c	/^static struct object_context *find_obj(const char *name) {$/;"	f	file:	signature:(const char *name)
format_message	dy_message.c	/^static void format_message(jd_var *out, jd_var *v) {$/;"	f	file:	signature:(jd_var *out, jd_var *v)
free_thread	dy_thread.c	/^static void free_thread(struct thread_context *ctx) {$/;"	f	file:	signature:(struct thread_context *ctx)
g#	Session.vim	/^nnoremap g# g#zz$/;"	m
g*	Session.vim	/^nnoremap g* g*zz$/;"	m
get_ctx	dy_object.c	/^static struct object_context *get_ctx(jd_var *o) {$/;"	f	file:	signature:(jd_var *o)
get_leaks	t/util.c	/^static size_t get_leaks(unsigned *count) {$/;"	f	file:	signature:(unsigned *count)
get_message	dy_despatch.c	/^static void get_message(jd_var *msg) {$/;"	f	file:	signature:(jd_var *msg)
gx	Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
h	dynatron.h	/^  } h;$/;"	m	struct:__anon4	typeref:union:__anon4::__anon5	access:public
h	dynatron.h	/^  } h;$/;"	m	struct:__anon7	typeref:union:__anon7::__anon8	access:public
hook_alloc	t/util.c	/^static void hook_alloc(void) {$/;"	f	file:	signature:(void)
is	t/tap.c	/^int is(long long got, long long want, const char *msg, ...) {$/;"	f	signature:(long long got, long long want, const char *msg, ...)
is	t/tap.h	/^int is(long long got, long long want, const char *msg, ...);$/;"	p	signature:(long long got, long long want, const char *msg, ...)
jdt_dump	t/jd_test.c	/^void jdt_dump(const char *label, jd_var *v) {$/;"	f	signature:(const char *label, jd_var *v)
jdt_dump	t/jd_test.h	/^void jdt_dump(const char *label, jd_var *v);$/;"	p	signature:(const char *label, jd_var *v)
jdt_is	t/jd_test.c	/^int jdt_is(jd_var *got, jd_var *want, const char *msg, ...) {$/;"	f	signature:(jd_var *got, jd_var *want, const char *msg, ...)
jdt_is	t/jd_test.h	/^int jdt_is(jd_var *got, jd_var *want, const char *msg, ...);$/;"	p	signature:(jd_var *got, jd_var *want, const char *msg, ...)
jdt_is_json	t/jd_test.c	/^int jdt_is_json(jd_var *got, const char *want, const char *msg, ...) {$/;"	f	signature:(jd_var *got, const char *want, const char *msg, ...)
jdt_is_json	t/jd_test.h	/^int jdt_is_json(jd_var *got, const char *want, const char *msg, ...);$/;"	p	signature:(jd_var *got, const char *want, const char *msg, ...)
li_shim	dy_listener.c	/^static void *li_shim(void *arg) {$/;"	f	file:	signature:(void *arg)
listen_cb	dy_listener.c	/^static int listen_cb(jd_var *rv, jd_var *ctx, jd_var *arg) {$/;"	f	file:	signature:(jd_var *rv, jd_var *ctx, jd_var *arg)
listener	dy_listener.c	/^static void listener(dy_io_reader *rd) {$/;"	f	file:	signature:(dy_io_reader *rd)
lvl	dy_log.c	/^static const char *lvl[] = {$/;"	v	file:
lvl_col	dy_log.c	/^static const char *lvl_col[] = {$/;"	v	file:
main	dynatron.c	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	t/util.c	/^int main(void) {$/;"	f	signature:(void)
memhdr	t/util.c	/^struct memhdr {$/;"	s	file:
memhdr::next	t/util.c	/^  struct memhdr *next;$/;"	m	struct:memhdr	typeref:struct:memhdr::memhdr	file:	access:public
memhdr::sig	t/util.c	/^  unsigned sig;$/;"	m	struct:memhdr	file:	access:public
memhdr::size	t/util.c	/^  size_t size;$/;"	m	struct:memhdr	file:	access:public
memlist	t/util.c	/^struct memhdr *memlist = NULL;$/;"	v	typeref:struct:memhdr
mention	utils.c	/^void mention(const char *msg, ...) {$/;"	f	signature:(const char *msg, ...)
mention	utils.h	/^void mention(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
merge	dy_listener.c	/^static void merge(jd_var *out, const char *dflt, jd_var *in) {$/;"	f	file:	signature:(jd_var *out, const char *dflt, jd_var *in)
monitor	dynatron.c	/^static void monitor(void) {$/;"	f	file:	signature:(void)
mutex	dy_log.c	/^static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
mutex	dynatron.h	/^  pthread_mutex_t mutex;$/;"	m	struct:__anon9	access:public
n	Session.vim	/^nnoremap n nzz$/;"	m
n	dynatron.h	/^    } n;$/;"	m	union:__anon4::__anon5	typeref:struct:__anon4::__anon5::__anon6	access:public
name	dy_object.c	/^  jd_var name, obj;$/;"	m	struct:object_context	file:	access:public
nest_in	t/tap.c	/^void nest_in(const char *p) {$/;"	f	signature:(const char *p)
nest_in	t/tap.h	/^void nest_in(const char *p);$/;"	p	signature:(const char *p)
nest_out	t/tap.c	/^void nest_out(void) {$/;"	f	signature:(void)
nest_out	t/tap.h	/^void nest_out(void);$/;"	p	signature:(void)
next	dy_thread.c	/^  struct thread_context *next;$/;"	m	struct:thread_context	typeref:struct:thread_context::thread_context	file:	access:public
next	t/util.c	/^  struct memhdr *next;$/;"	m	struct:memhdr	typeref:struct:memhdr::memhdr	file:	access:public
not_null	t/tap.c	/^int not_null(const void *p, const char *msg, ...) {$/;"	f	signature:(const void *p, const char *msg, ...)
not_null	t/tap.h	/^int not_null(const void *p, const char *msg, ...);$/;"	p	signature:(const void *p, const char *msg, ...)
npfx	t/tap.c	/^static size_t npfx = 0;$/;"	v	file:
null	t/tap.c	/^int null(const void *p, const char *msg, ...) {$/;"	f	signature:(const void *p, const char *msg, ...)
null	t/tap.h	/^int null(const void *p, const char *msg, ...);$/;"	p	signature:(const void *p, const char *msg, ...)
obj	dy_object.c	/^  jd_var name, obj;$/;"	m	struct:object_context	file:	access:public
object_context	dy_object.c	/^struct object_context {$/;"	s	file:
object_context::name	dy_object.c	/^  jd_var name, obj;$/;"	m	struct:object_context	file:	access:public
object_context::obj	dy_object.c	/^  jd_var name, obj;$/;"	m	struct:object_context	file:	access:public
object_context::queue	dy_object.c	/^  dy_queue *queue;$/;"	m	struct:object_context	file:	access:public
object_tell	dy_object.c	/^static int object_tell(jd_var *rv, jd_var *ctx, jd_var *arg) {$/;"	f	file:	signature:(jd_var *rv, jd_var *ctx, jd_var *arg)
object_worker	dy_object.c	/^static void object_worker(jd_var *obj) {$/;"	f	file:	signature:(jd_var *obj)
ok	t/tap.c	/^int ok(int flag, const char *msg, ...) {$/;"	f	signature:(int flag, const char *msg, ...)
ok	t/tap.h	/^int ok(int flag, const char *msg, ...);$/;"	p	signature:(int flag, const char *msg, ...)
parse_options	dynatron.c	/^static void parse_options(int *argc, char ***argv) {$/;"	f	file:	signature:(int *argc, char ***argv)
pass	t/tap.c	/^int pass(const char *msg, ...) {$/;"	f	signature:(const char *msg, ...)
pass	t/tap.h	/^int pass(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
pfx	t/tap.c	/^static const char *pfx[MAX_PREFIX];$/;"	v	file:
ping_cb	dy_listener.c	/^static int ping_cb(jd_var *rv, jd_var *ctx, jd_var *arg) {$/;"	f	file:	signature:(jd_var *rv, jd_var *ctx, jd_var *arg)
pos	dynatron.h	/^  unsigned pos;$/;"	m	struct:__anon4	access:public
prefix	t/tap.c	/^static void prefix(void) {$/;"	f	file:	signature:(void)
queue	dy_despatch.c	/^static dy_queue *queue;$/;"	v	file:
queue	dy_listener.c	/^static dy_queue *queue;$/;"	v	file:
queue	dy_object.c	/^  dy_queue *queue;$/;"	m	struct:object_context	file:	access:public
queue	dynatron.h	/^  jd_var queue;$/;"	m	struct:__anon9	access:public
receive	perl/lib/Dynatron/Client.pm	/^sub receive {$/;"	s
registry	dy_object.c	/^static jd_var registry = JD_INIT;$/;"	v	file:
remove_thread	dy_thread.c	/^static void remove_thread(struct thread_context *ctx) {$/;"	f	file:	signature:(struct thread_context *ctx)
run_h	dy_core.c	/^static int run_h(jd_var *self, jd_var *ctx, jd_var *arg) {$/;"	f	file:	signature:(jd_var *self, jd_var *ctx, jd_var *arg)
s:cpo_save	Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	Session.vim	/^let s:l = 102 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 102 - ((18 * winheight(0) + 19) \/ 38)$/;"	v
s:l	Session.vim	/^let s:l = 119 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 134 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 20 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 22 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 26 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 34 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 47 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 5 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 54 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 72 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:l	Session.vim	/^let s:l = 81 - ((28 * winheight(0) + 19) \/ 38)$/;"	v
s:l	Session.vim	/^let s:l = 9 - ((0 * winheight(0) + 0) \/ 1)$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
send	perl/lib/Dynatron/Client.pm	/^sub send {$/;"	s
sender	dy_listener.c	/^static void sender(dy_io_writer *wr) {$/;"	f	file:	signature:(dy_io_writer *wr)
shim	dy_listener.c	/^static void shim(int r, int w, jd_var *arg) {$/;"	f	file:	signature:(int r, int w, jd_var *arg)
sig	t/util.c	/^  unsigned sig;$/;"	m	struct:memhdr	file:	access:public
size	dynatron.h	/^      size_t size, used;$/;"	m	struct:__anon4::__anon5::__anon6	access:public
size	t/util.c	/^  size_t size;$/;"	m	struct:memhdr	file:	access:public
slurp	tools/version.pl	/^sub slurp($) {$/;"	s
socket_listener	dy_listener.c	/^static void socket_listener(jd_var *arg) {$/;"	f	file:	signature:(jd_var *arg)
split_lines	dy_log.c	/^static void split_lines(jd_var *out, jd_var *v) {$/;"	f	file:	signature:(jd_var *out, jd_var *v)
sstrdup	utils.c	/^char *sstrdup(const char *s) {$/;"	f	signature:(const char *s)
sstrdup	utils.h	/^char *sstrdup(const char *s);$/;"	p	signature:(const char *s)
t_alloc	t/util.c	/^static void *t_alloc(size_t size) {$/;"	f	file:	signature:(size_t size)
t_free	t/util.c	/^static void t_free(void *m) {$/;"	f	file:	signature:(void *m)
test	t/tap.c	/^int test(int flag, const char *msg, va_list ap) {$/;"	f	signature:(int flag, const char *msg, va_list ap)
test	t/tap.h	/^int test(int flag, const char *msg, va_list ap);$/;"	p	signature:(int flag, const char *msg, va_list ap)
test_done	t/util.c	/^void test_done(void) {$/;"	f	signature:(void)
test_done	t/util.h	/^void test_done(void);$/;"	p	signature:(void)
test_init	t/util.c	/^void test_init(void) {$/;"	f	signature:(void)
test_init	t/util.h	/^void test_init(void);$/;"	p	signature:(void)
test_main	t/util.h	/^void test_main(void);$/;"	p	signature:(void)
test_no	t/tap.c	/^static int test_no = 0;$/;"	v	file:
thd	dy_thread.c	/^  pthread_t thd;$/;"	m	struct:thread_context	file:	access:public
thread_context	dy_thread.c	/^struct thread_context {$/;"	s	file:
thread_context::arg	dy_thread.c	/^  jd_var arg;$/;"	m	struct:thread_context	file:	access:public
thread_context::next	dy_thread.c	/^  struct thread_context *next;$/;"	m	struct:thread_context	typeref:struct:thread_context::thread_context	file:	access:public
thread_context::thd	dy_thread.c	/^  pthread_t thd;$/;"	m	struct:thread_context	file:	access:public
thread_context::worker	dy_thread.c	/^  dy_worker worker;$/;"	m	struct:thread_context	file:	access:public
to_c	tools/json2c.pl	/^sub to_c {$/;"	s
ts	dy_log.c	/^static void ts(char *buf, size_t sz) {$/;"	f	file:	signature:(char *buf, size_t sz)
type	dynatron.h	/^  dy_io_type type;$/;"	m	struct:__anon4	access:public
type	dynatron.h	/^  dy_io_type type;$/;"	m	struct:__anon7	access:public
unhook	t/util.c	/^static struct memhdr *unhook(struct memhdr *list, struct memhdr *h) {$/;"	f	file:	signature:(struct memhdr *list, struct memhdr *h)
unlink	dy_thread.c	/^static struct thread_context *unlink(struct thread_context *this,$/;"	f	file:	signature:(struct thread_context *this, struct thread_context *node)
usage	dynatron.c	/^static void usage() {$/;"	f	file:
used	dynatron.h	/^      size_t size, used;$/;"	m	struct:__anon4::__anon5::__anon6	access:public
v	dynatron.h	/^    jd_var v;$/;"	m	union:__anon4::__anon5	access:public
v	dynatron.h	/^    jd_var v;$/;"	m	union:__anon7::__anon8	access:public
v_date	utils.c	/^const char *v_date = V_DATE;$/;"	v
v_git_hash	utils.c	/^const char *v_git_hash = V_GIT_HASH;$/;"	v
v_info	utils.c	/^const char *v_info = V_INFO;$/;"	v
v_version	utils.c	/^const char *v_version = V_VERSION;$/;"	v
verbose	utils.c	/^int verbose = 0;$/;"	v
version	utils.c	/^void version() {$/;"	f
version	utils.h	/^void version();$/;"	p	signature:()
warn	utils.c	/^void warn(const char *msg, ...) {$/;"	f	signature:(const char *msg, ...)
warn	utils.h	/^void warn(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
worker	dy_thread.c	/^  dy_worker worker;$/;"	m	struct:thread_context	file:	access:public
wrapper	dy_thread.c	/^static void *wrapper(void *ctxp) {$/;"	f	file:	signature:(void *ctxp)
zt	Session.vim	/^normal! zt$/;"	m
